# -*- coding: utf-8 -*-
"""Proyecto mora.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WF7askZM0EYudVb-fq_tJEbBew1DmR75
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np

dataset = pd.read_csv(r'/content/drive/MyDrive/crop_recommendation_unida_corregida.xlsx - Sheet1.csv')
dataset.head()

datasetf=dataset.drop(['Unnamed: 0','crop','depto_code','id_depto','departamento_colombia','zona_vida', 'temperature_min','temperature_max','rainfall_min','rainfall_max','Longitud','Latitud'], axis=1)
datasetf.head()

datasetf.info()

datasetf['rainfall'] = (
    datasetf['rainfall']
    .str.replace(',', '.', regex=False)  # cambia coma por punto decimal
    .astype(float)
)

datasetf.head()

#2. split into input (X) and output (Y) variables
datasetma = np.array(datasetf)

# Set de datos "diabetes" (los datos van desde la columna 0 a la 7)
# Columnas [0]=Pregnancies	Glucose	BloodPressure	SkinThickness	Insulin	BMI	DiabetesPedigreeFunction	[7]=Age
X = datasetma[:,0:8]

# Outcome (salida) El outcome (resultado) se encuentra en la última columna (8)
# Columna [8]=Outcome
Y = datasetma[:,8]

print("Entradas")
print(X)

print("")
print("Outcome - Salida")
print(Y)

#3. Split input and output into training (Reference) and testing sets
import sklearn
from sklearn.model_selection import train_test_split

# Entrenamiento y Testing
# Son procesos separados. Primera se entrena la máquina y después se prueba
#
# La función se encarga de hacer un "split" de los datos de entrenamiento y testing
# test_size = % de datos de entrenamiento - aleatorios
[X_train, X_test, Y_train, Y_test]= train_test_split(X,Y,test_size=0.5,random_state=1)


print("Datos X: Entrenamiento")
print(X_train)
print()
print("Datos X: Testing:")
print(X_test)

#4. ESTANDARIZACIÓN DE DATOS (Data stardardization)
from sklearn.preprocessing import StandardScaler

# Estandarización de los datos
scaler  = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test  = scaler.transform(X_test)

from sklearn.preprocessing import MinMaxScaler
scaler2 = MinMaxScaler()
X_train = scaler2.fit_transform(X_train)
X_test  = scaler2.transform(X_test)

from sklearn.metrics import confusion_matrix as CM,ConfusionMatrixDisplay
from sklearn.metrics import accuracy_score as ACC
from sklearn.metrics import precision_score as PR
from sklearn.metrics import recall_score as RC
from sklearn.metrics import f1_score as F1

#5. Utilizando el clasificador KNN
from sklearn.neighbors import KNeighborsClassifier as KNN

# Modelo KNN
Model_KNN = KNN(5)

# Entrenamiento
Model_KNN.fit(X_train, Y_train)

# Predicción
Y_pred_KNN = Model_KNN.predict(X_test)

# Graficando resultados
print('Mostrando el Esperado y la Predicción (expected y predicted)')
for j in range(0,len(Y_test)):
    valor_esperado   = Y_test[j]
    valor_prediccion = Y_pred_KNN[j]
    if (valor_esperado == valor_prediccion):
        print ('Deberìa ser: ',Y_test[j],'-----','Salió: ',Y_pred_KNN[j])
    else:
        if (valor_prediccion > valor_esperado):
            print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_KNN[j], "Falso Positivo")
        else:
            print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_KNN[j], "Falso Negativo")
print('')

# Evaluado desempeño
# MAtriz de Confusión
# Positivos / Falsos positivos
matriz_confu_knn = CM(Y_test, Y_pred_KNN, labels=Model_KNN.classes_)
disp     = ConfusionMatrixDisplay(confusion_matrix = matriz_confu_knn, display_labels=Model_KNN.classes_)
disp.plot()

# Muestra resultados
print("Accuracy  KNN: ", 100*round(ACC(Y_test, Y_pred_KNN),2))
print("Precision KNN: ", 100*round( PR(Y_test, Y_pred_KNN, average='macro'),2))
print("Recall    KNN: ", 100*round(RC(Y_test,  Y_pred_KNN, average='macro'),2))
print("F1_Score  KNN: ", 100*round(F1(Y_test,  Y_pred_KNN, average='macro'),2))

from sklearn.naive_bayes import GaussianNB
# Modelo Gaussiano
Modelo_2 = GaussianNB()
Modelo_2.fit(X_train, Y_train)
Y_pred_2 =Modelo_2.predict (X_test)
# Graficando resultados
print('Mostrando el Expected y predicted')
for j in range(0,len(Y_test)):
  print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_2[j])
print('')

# Evaluado desempeño
Matriz_2 = CM(Y_test, Y_pred_2, labels=Modelo_2.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=Matriz_2,display_labels=Modelo_2.classes_)
disp.plot()

print("Accuracy Bayes",ACC(Y_test, Y_pred_2))
print("Precision Bayes",PR(Y_test, Y_pred_2, average='macro'))
print("Recall Bayes",RC(Y_test, Y_pred_2, average='macro'))
print("F1_Score Bayes",F1(Y_test, Y_pred_2, average='macro'))

#7. Evaluando casos mediante LDA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
Modelo_3 = LDA()
Modelo_3.fit(X_train, Y_train)
Y_pred_3 =Modelo_3.predict (X_test)
# Graficando resultados
print('Mostrando el Esperado y la Predicción (expected y predicted)')
for j in range(0,len(Y_test)):
    valor_esperado   = Y_test[j]
    valor_prediccion = Y_pred_3[j]
    if (valor_esperado == valor_prediccion):
        print ('Deberìa ser: ',Y_test[j],'-----','Salió: ',Y_pred_3[j])
    else:
        if (valor_prediccion > valor_esperado):
            print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_3[j], "Falso Positivo")
        else:
            print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_3[j], "Falso Negativo")
print('')
#Evaluado desempeño
Matriz_3 = CM(Y_test, Y_pred_3, labels=Modelo_3.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=Matriz_3,display_labels=Modelo_3.classes_)
disp.plot()
print("Accuracy LDA",ACC(Y_test, Y_pred_3))
print("Precision LDA",PR(Y_test, Y_pred_3, average='macro'))
print("Recall LDA",RC(Y_test, Y_pred_3, average='macro'))
print("F1_Score LDA",F1(Y_test, Y_pred_3, average='macro'))

#9. Evaluando casos mediante Logistic regression
from sklearn.linear_model import LogisticRegression as LR
Modelo_5 = LR()
Modelo_5.fit(X_train, Y_train)
Y_pred_5 =Modelo_5.predict (X_test)
# Graficando resultados
print('Mostrando el Esperado y la Predicción (expected y predicted)')
for j in range(0,len(Y_test)):
    valor_esperado   = Y_test[j]
    valor_prediccion = Y_pred_5[j]
    if (valor_esperado == valor_prediccion):
        print ('Deberìa ser: ',Y_test[j],'-----','Salió: ',Y_pred_5[j])
    else:
        if (valor_prediccion > valor_esperado):
            print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_5[j], "Falso Positivo")
        else:
            print ('Deberìa ser: ',Y_test[j],'-----','Pero salió: ',Y_pred_5[j], "Falso Negativo")
print('')
#Evaluado desempeño
Matriz_5 = CM(Y_test, Y_pred_5, labels=Modelo_5.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=Matriz_5,display_labels=Modelo_5.classes_)
disp.plot()
print("Accuracy LR",ACC(Y_test, Y_pred_5))
print("Precision LR",PR(Y_test, Y_pred_5, average='macro'))
print("Recall LR",RC(Y_test, Y_pred_5, average='macro'))
print("F1_Score LR",F1(Y_test, Y_pred_5, average='macro'))

import joblib

joblib.dump(Modelo_5, 'modelo_entrenado.pkl')